/*
목표 : 게임 준비하기


    1. 스프라이트를 담을 폴더 준비하기

    2. 다운 받은 스프라이트 설정
        PixelPerUnit, FilterMode, Compression 설정
        스프라이트 에디터에서 스프라이트 자르기

    3. 플레이어 스프라이트 씬에 배치

    4. 스크립트 폴더 준비하기
*/

/*
목표 : 플레이어 이동


    1. 플레이어 스크립트 만들기

    2. 오브젝트에 스크립트 부착

    3. 이동 로직을 위한 필요 속성 : 수평/수직 방향값을 받아서 저장할 변수, 플레이어의 현재 위치, 플레이어의 다음 위치, 속도, 

    4. transform을 활용한 이동 로직 만들기
        미래의 위치는 현재의 위치 + 속도 * 시간
*/

/*
목표 : 해상도 조절


    1. 유니티 레이아웃 조정

    2. 9 : 16 비율로 화면 조정
        9 : 19 비율도 가능

    3. 플레이어 위치 재 조정
*/

/*
목표 : 경계 설정


    1. 플레이어 오브젝트에 콜라이더 부착
        콜라이더 크기 조절

    2. 빈 오브젝트 만들기
        빈 오브젝트 자식으로 상/하/좌/우 빈 오브젝트 만들기
        자식 오브젝트에게 콜라이더 부착
            콜라이더 크기를 화면 경계선 크기로 조절

    3. 플레이어 오브젝트에 리지드바디 부착
        BodyType Kinematics으로 설정하여 충돌 물리연산을 받지 않도록 한다.
            이러면 스크립트 로직으로만 움직이게 할 수 있다.

    4. 경계선에도 리지드바디 부착
        BodyType Static으로 설정하여 고정한다.
*/

/*
목표 : 경계 로직


    1. 플레이어가 경계선에 닿으면 해당 방향으로의 이동 값을 0로 만든다.

    2. 필요 속성 : 상/하/좌/우 경계선에 닿았는지 체크할 bool 변수

    3. 통과 이벤트 함수(OnTrigger)를 만들어서 경계선과의 충돌을 체크한다.
        태그로 경계선과의 충돌을 체크한다.
            스위치 문의 이름으로 어떤 방향 경계선에 닿았는지 체크한다.
    
    4. 경계선에 닿았는데 AxisRaw 값이 1,-1이라면 0으로 만든다.

    5. 경계선에서 벗어낫을 때 통과 이벤트 함수(Exit)만들어서 경계선에서 벗어났는지 체크한다.

    6. 경계선 자식 오브젝트에 태그를 추가해 준다.

    7. 경계선 자식 오브젝트의 콜라이더는 트리거로 전환한다.
*/

/*
목표 : 플레이어의 애니매이션


    1. 움직임에 따른 애니매이션 클립을 만든다.

    2. 애니매이터에서 트랜지션을 연결한다.

    3. 정수형 파라미터를 만든다.
        직진은 수평값이 0
        오른쪽은 수평값이 1
        왼쪽은 수평값이 -1

    4. 방향키가 입력됬을 때와 방향키 입력이 끝날 때 파라미터에 값을 전달하면 된다.

    5. 필요 속성 : 애니매이터

    6. 수평값의 키가 눌렸을 때, 때였을 때 파라미터에 수평 값을 전달한다.
*/

/*
목표 : 발사체 구성


    1. 씬에 총알 스프라이트 배치

    2. 총알 오브젝트에 콜라이더와 리지드바디 부착
        총알은 AddForce를 활용하여 발사할 예정이기 때문에 BodyType은 Dynamic으로 지정한다.
        총알은 중력의 영향을 받지 않을 것 이기 때문에 중력값 또한 0으로 지정한다.

    3. 총알 오브젝트를 에셋화(프리팹)한다.
        프리팹 폴더를 준비한다.
*/

/*
목표 : 오브젝트 삭제


    1. 총알이 쌓이지 않도록 오브젝트 경계선을 만든다.

    2. 총알을 관리할 총알 스크립트를 만든다.

    3. 총알 스크립트에서 경계선과 충돌했을 때 스스로 제거하는 함수(OnTrigger)를 만든다.

    4. 총알 경계선 전용 태그를 만든다.

    5. 씬에 배치해 둔 총알 오브젝트는 지워준다.
*/

/*
목표 : 총알 만들기


    1. 총알은 플레이어 스크립트에서 사용하도록 한다.

    2. 필요 속성 : 총알 프리팹을 담을 게임 오브젝트 변수

    3. 총알 발사 로직을 작성하기 전에 이전에 만들어 두었던 이동 로직을 캡슐화 하여 Update()함수를 정리한다.

    4. 발사 함수를 만든다.

    5. Instantiate()를 통해 프리팹에서 총알을 객체화 시킨다.
        그리고 이 객체를 게임 오브젝트 변수로 저장한다.
        플레이어 위치에서 발사하고 플레이어 방향으로 발사한다.
    
    6. 저장된 게임 오브젝트로 부터 Rigidbody2D를 받아온다.
        AddForce로 발사한다.

    7. public 으로 만들었던 속성에 프리팹을 배정한다.

    8. 총알 프리팹에 부착된 콜라이더에 트리거를 체크한다.
*/

/*
목표 : 발사체 다듬기


    1. 사용자가 발사 버튼을 눌렀을 때만 총알을 발사하도록 한다.
        발사 버튼을 누르지 않았다면 반환한다.

    2. 총알 발사 딜레이를 준다.

    3. 필요 속성 : 최대 총알 발사 속도와 현재 총알 발사 속도 변수

    4. 장전 함수를 만든다.
        현재 발사 속도에 시간을 매 프레임 마다 더한다.

    5. 다시 발사 함수에서 (현재 발사 속도 < 최대 발사 속도) 이면 총알을 발사하지 않는다.

    6. 총알을 한 발 발사 하였다면 현재 발사 속도를 초기화 한다.
*/

/*
목표 : 더 강한 총알 발사


    1. 필요 속성 : 파워를 수치화 한 변수

    2. Fire() 함수로 가서 파워 변수에 따른 각기 다른 총알 발사를 작성한다.

    3. switch 문으로 파워가 1일 때, 2일 때, 3일 때 각기 다른 총알을 발사한다.
        1일 때는 기존 발사체 그대로
        2일 때는 기존 발사체를 두 발 발싸
            객체화 할 때 위치를 수정해 준다.
        3일 때는 더 강한 총알을 추가로 발싸
*/

/*
목표 : 적 기체 준비하기


    1. 적 기체들을 씬에 옮긴다.

    2. 각 기체에 콜라이더를 부착한다.
        스프라이트 에디터에서 폴리곤 콜라이더를 위해 PhysicsShape를 수정해 준다.

    3. 각 기체도 움직이는 속력 값이 있기 때문에 리지드바디를 부착한다.
        중력은 받으면 않된다.

    4. 태그를 추가해 준다.
*/

/*
목표 : 적 기초 로직 만들기


    1. 스크립트 만들고 부착

    2. 필요 속성 : 속도, 체력, 리지드바디, 피격 상태를 위한 스프라이트 렌더러, 스프라이트를 바꾸기 위한 스프라이트 배열

    3. 리지드바디 + 스프라이트 렌더러를 초기화 한다. 그리고 적 기체가 탄생하면 바로 아래로 내려가도록 속력도 초기화 한다.
        velocity로 속력을 초기화 한다.

    4. 플레이어의 총알을 맞았을 때 호출되는 함수를 만든다.
        매개 변수로 피격 데미지를 받는다.
        체력에서 데미지를 빼준다.
        체력이 0보다 작아진다면 해당 오브젝트를 제거한다.
        스프라이트를 교체한다.

    5. 스프라이트가 원상태로 돌아오는 함수를 만든다.
        스프라이트를 기본으로 교체한다.
        피격 함수에서 Invoke()를 통해 스프라이트 함수를 호출한다.

    6. 충돌 함수(OnTrigger)를 만든다.
        만약 충돌한 콜라이더가 총알 경계선일 경우 오브젝트를 제거한다.
        만약 충돌한 콜라이더가 플레이어 총알이라면 피격 함수를 호출한다.
            피격함수의 매개변수로 데미지를 전달해야 한다.
            총알 스크립트 변수를 만들어서 총알 데미지를 받아온다.
                현재 총알 스크립트에 데미지 속성이 없으므로 추가해 준다.

    7. 적에게 부착된 콜라이더의 트리거를 켜준다.

    8. 플레이어 총알이 적에게 충돌하면 충돌한 총알은 사라져야 한다.
        적이 충돌한 콜라이더가 플레이어 총알이라면 피격 함수를 호출한 뒤 충돌한 오브젝트를 제거한다.

    9. 로직이 모두 완성되었다면 적 오브젝트를 모두 프리팹으로 저장한다.
*/

/*
목표 : 적 기체 생성


    1. 게임 매니저를 만든다.

    2. 필요 속성 : 적 공장 배열(3개), 적이 나타날 위치(Transform)배열, 적 생성 시간, 현재 딜레이 시간

    3. 매 프레임마다 현재 딜레이 시간은 계속해서 증가한다.
        만약 딜레이 시간이 적 생성 시간보다 커질 경우 적을 생성한다.
        적을 생성한 뒤에는 딜레이 시간을 초기화 한다.
        적을 한 번 생성하였다면 적 생성 시간을 랜덤 시간으로 초기화 한다.

    4. 적 생성 함수를 만든다.
        3가지 적 중 랜덤한 적을 고른다.
        5가지 소환될 위치도 랜덤한 위치로 고른다.
        Instantiate()를 통해 적을 객체화 한다.

    5. 빈 오브젝트를 만들어서 적이 생성될 위치에 나열한다.
*/

/*
목표 : 적 기체가 사이드에서 생성


    1. 씬에 생성 위치를 추가로 만든다.

    2. 랜덤 스폰 포인트의 범위를 수정한다.

    3. 사이드에서 생성된 적은 아래로 내려가면 않된다.
        그러므로 적 스크립트에서 지정 했었던 리지드바디와 속력은 제거한다.
        총알과 마찬가지로 인스턴스화되는 때에 방향과 속도를 지정하여 적을 이동 시킨다.
            적을 인스턴스화 할 때 해당 객체를 저장하고 리지드 바디를 받아온다.
            적 스크립트도 저장하여 속력 속성을 사용하도록 한다.

    4. 사이드 오른쪽일 때 속력 * -1로 x축 방향, 플레이어가 앞으로 전진하는 느낌이 들도록 내려가는 -1 속력을 지정한다.
        반대의 경우도 마찬가지로 지정한다.

    5. 사이드가 아닐 때는 x 축은 0, y축으로 속도를 * 연산하여 적을 이동시킨다.

    6. 사이드에서 날아올 때 객체를 회전 시켜준다.
        Z축으로 Rotate 시킨다. back = -1 이므로 * 90도를 하여 방향을 잡는다.
        반대는 front로 한다.
*/

/*
목표 : 적 기체가 플레이어를 공격

    
    1. 플레이어의 총알 프리팹을 복사하여 수정해서 적 총알 프리팹으로 사용한다.

    2. 적 총알 태그를 추가한다.

    3. 필요 속성 : 플레이어가 총알을 발사할 때 필요했던 것, 총알 공장, 총알 딜레이

    4. 플레이어는 버튼을 눌렀을 때만 발사 했지만 적은 자동으로 발사한다.

    5. 플레이어 로직에서 발사 함수와 재장전 함수를 복사하여 수정을 하도록 한다.
        적은 파워 개념이 없으므로 파워에 따른 총알 발사 로직은 모두 지운다.
        적은 버튼을 누를 필요가 없다.
        S타입과 L타입의 공격을 제어문으로 나눈다. 이때 구분은 오브젝트 이름으로 구분하도록 한다.
            속성으로 적 이름을 추가하도록 한다.
        기본 플레이어의 총알 발사 로직에서 어디를 향해 쏠지를 수정해 준다.
            플레이어에게 발사하기 위해서 플레이어 변수가 필요하다.
                그런데 프리팹이기 때문에 public 속성으로 추가해도 프리팹 상태에서는 값을 받을 수 없다.
                때문에 프리팹이 인스턴스화 한 순간에 플레이어 변수를 받아와야 한다.
                    이는 게임 매니저가 해줘야 한다.
                        게임 매니저가 플레이어 오브젝트 변수를 갖는다.
                        적 스크립트에도 똑같이 플레이어 오브젝트 변수를 선언해 둔다.
                        게임 매니저에서 적을 생성하는데 이 때, 생성될 때 우리는 적의 속도를 사용하기 위해 적 스크립트도 받았었다.
                            적 스크립트를 이용해 플레이어 오브젝트 변수를 받아와 게임 매니저와 연동한 플레이어를 넘겨준다.
            목표물 방향 = 목표물 위치 - 나의 위치
                즉, 플레이어의 위치 - 적의 위치가 플레이어를 향하는 방향이다. 이를 벡터로 저장하고 총알 발사 방향으로 지정해 준다.
        S타입은 한발만 발사 하는데 L타입은 두발을 발사하도록 한다.
            플레이어 파워 2 버전을 참고하여 발사한다.
        
    6. 총알이 너무 빠르다.
        좌표값이 포함된 벡터의 크기가 큼으로 일반화가 필요하다.
*/

/*
목표 : 플레이어 피격


    1. 플레이어 충돌 함수(OnTriggerEnter2D)에 충돌하는 태그를 제어문에서 추가해준다.

    2. 적 + 적 총알에 충돌하였을 때 플레이어를 비활성화 시킨다.

    3. 플레이어가 비활성화 된 상태에서는 로직이 실행되지 않는다.
        그러므로 게임 매니저에서 플레이어에를 부활시킬 함수를 만든다.
            부활 함수에서 다시 Invke()함수로 부활 실행 함수를 호출한다.
                부활 실행 함수를 만든다.
                플레이어의 위치를 지정해 주고 다시 활성화 시킨다.

    4. 플레이어가 게임 매니저의 활성화 함수를 호출하기 위해서 게임 매니저를 변수로 받는다.
*/

/*
목표 : 목숨과 점수


    1. 필요 속성 : 목숨, 점수

    2. 점수를 표시할 Text UI, 목숨을 표시할 Image UI를 만들어 준다.
        Canvas Scaler : UI Scale Mode를 Scale With Screen Size로 변경한다.
            1080 X 1920 Size를 기준으로 잡는다.
    
    3. 게임 오버 Text UI도 만들어 준다.

    4. 재시작 Button UI도 만들어 준다.
        스프라이트 에디터에서 Borader 설정

    5. 게임 오버와 재시작은 빈 오브젝트의 자식으로 묶어서 비활성화 시켜 놓는다.
*/

/*
목표 : UI 로직


    1. 적 스크립트에 OnHit()함수를 만들어 두었었다.

    2. 적이 플레이어 총알에 피격될 때 플레이어에게 자신의 점수를 더해 준다.
        적에게 점수 속성을 추가한다.
        플레이어 로직 컴포넌트를 받아온 뒤 점수 속성에 더하기 연산을 한다.

    3. 점수는 게임 매니저에서 출력한다.
        먼저 Text UI를 속성으로 받아온다.
        내친김에 Image UI도 속성으로 받아온다. 이것은 배열이다.
        마지막으로 게임 오버 세트를 GameObject로 받는다.

    4. Update()함수에서 매 프레임 마다 플레이어 로직으로 부터 점수를 받아와 Text로 출력한다.
        string.Format("0:n0", 점수)

    5. 목숨을 잃는 부분은 플레이어 스크립트에 OnTriggerEnter2D에서 적이나 적 총알에 충돌했을 때 이다.
        목숨 속성을 -1 한다.
        게임 매니저에 목숨 이미지를 제거하는 함수를 만들어 준다.
            매개변수로 플레이어 속성인 목숨을 받는다.
            반복문으로 최대 목숨 갯수만큼 알파값을 지워서 투명하게 만들고
            반복문으로 현재 목수 갯수만큼 알파값을 올려서 그려준다.
    
    6. 플레이어의 목숨이 0이된다면?
        게임 매니저에 게임 오버 함수를 만들어 준다.
            만들어 둔 게임 오버 set UI를 활성화 시킨다.

    7. 재시작 버튼을 누르면 씬을 새로 불러오는 함수를 만든다.

    8. 재시작 버튼에 함수를 연결한다.
*/

/*
목표 : 버그( 플레이어가 총알 두개에 동시 피격될 경우 목숨이 한 꺼번에 두 개 깍인다. )

    
    1. 한 발 맞는 순간 해당 로직을 닫는 플래그를 만든다.

    2. 필요 속성 : 피격되었다는 bool 변수

    3. 이미 피격 상태 true라면 로직을 실행하지 않고 바로 반환한다.

    4. 피격 전 상태 false라면 true로 바꾸고 로직을 실행한다.

    5. 게임 매니저에서 플레이어를 다시 활성화 할 때 false로 바꿔준다.
        플레이어 로직을 받아와서 속성을 바꾼다.
*/

/*
목표 : 아이템 배치


    1. 아이템 스프라이트 씬에 나열

    2. 아이템에 리지드바디와 콜라이더를 부착한다.
        중력은 0

    3. 아이템 스크립트를 만들고 부착한다.

    4. 필요 속성 : 아이템 이름, 리지드바디

    5. 아이템도 객체 생성과 함께 속도를 초기화 해준다.

    6. 아이템 애니매이션 등록록
*/

/*
목표 : 아이템 충돌 로직


    1. 아이템 태그 만들기

    2. 플레이어 스크립트에 있는 충돌 로직 OnTriggerEnter2D에서 아이템과 충돌할 경우를 작성한다.

    3. 충돌한 아이템으로 부터 Item 로직을 받아와서 해당 아이템의 이름을 받는다.

    4. switch문으로 아이템 이름에 따라 로직을 작성한다.

    5. 코인을 먹으면 점수를 더한다.

    6. 파워를 먹으면 파워를 더한다.
        파워의 한계가 있기 때문에 최대 파워를 속성으로 추가해 준다.
        만약 파워가 최대 파워와 같다면 파워를 먹으면 점수로 치환된다.

    7. 폭탄을 먹으면 모든 적의 총알이 제거되고 적에게 데미지를 입힌다.
*/

/*
목표 : 폭탄 로직


    1. 폭탄 이펙트를 만든다.

    2. 애니매이션 등록

    3. 애니매이션 속도를 높인다.

    4. 알파값을 살짝 조정해 준다.

    5. 비활성화 시켜 둔다.

    6. 필요 속성 : 플레이어가 활성화 할 수 있도록 폭탄 이펙트를 게임 오브젝트로 받는다.

    7. 다시 switch 문으로 돌아가 폭탄 이펙트를 활성화 시킨다.

    8. 게임 오브젝트 배열로 화면 상에 있는 적들을 모두 받아온다.
        GameObject.FindGameObjectsWithTag("Enemy");

    9. 받은 오브젝트 배열을 반복문으로 돌린다.
        각각의 적 스크립트를 받고 OnHit()함수를 호출하여 데미지를 전달한다.

    10. 배열로 적들을 모두 받아왔듯이 적 총알을 받아와서 반복문으로 제거한다.

    11. 폭탄 이펙트를 비활성화 시키는 함수를 만든다.
        Invoke로 비활성화 시킨다.

    12. switch문에서 빠져나와서 충돌한 아이템을 삭제한다.
*/

/*
목표 : 버튼을 눌렀을 때 폭탄 사용


    1. 필요 속성 : 최대 폭탄 갯수와 현재 폭탄 갯수, 현재 폭탄을 사용 중인지 확인할 bool

    2. 폭탄 발사 함수를 만든다.

    3. 발사 버튼을 누르지 않았다면 폭탄을 발사하지 않고 반환한다.

    4. 이미 폭탄이 발사 중이라면 마찬가지로 반환한다.

    5. 폭탄의 갯수가 0개이면 마찬가지로 반환한다.

    6. 폭탄을 사용했으므로 현재 폭타의 개수를 한 개 줄인다.

    7. switch문에 적어 두었던 폭탄 기능을 모두 폭탄 발사 함수로 옮긴다.

    8. 기존 switch문에는 power와 동일한 방식으로 폭탄의 갯수를 증가 시킨다.

    9. 폭탄 이펙트를 비활성화 할 때 bool 변수에 false를 준다.

    10. 폭탄 UI를 만든다.

    11. 폭탄 UI 역시 게임 매니저가 그린다.
        Image 배열로 폭탄 이미지를 받는다.

    12. 목숨을 그린 방식과 똑같이 그린다.

    13. 플레이어가 폭탄을 먹었을 때, 사용했을 때 마다 게임 매니저의 폭탄 그리기 함수를 호출한다.

    14. 시작할 떄는 폭탄이 0개 이므로 씬에 그려둔 폭탄 이미지는 알파값을 0으로 둔다.
*/

/*
목표 : 아이템 드랍


    1. 아이템 프리펩 화

    2. 적이 죽으면 아이템이 일정 확률로 나온다.

    3. 필요 속성 : 종류별 아이템 프리펩

    4. 적이 죽을 때 랜덤한 숫자를 정수로 받는다.

    5. 확률을 지정하여 아이템을 인스턴스화 한다.

    6. 적이 제거되기 전에 연속해서 여러발을 맞을 경우 아이템을 여러개 생성하는 경우가 생긴다.
        이미 체력이 0보다 낮다면 더이상 OnHit 함수를 실행하지 않고 반환한다.
*/

/*
목표 : 배경 구성하기


    1. 배경을 3개의 그룹으로 나누어 관리한다.
        그룹당 같은 이미지를 3개씩 넣는다.

    2. 위 아래로 -10, +10 이미지를 나눈다.

    3. 이미지 스크립트를 만들고 그룹에 부착한다.

    4. 필요 속성 : 속도

    5. 현재 위치와 미래 위치를 이용하여 매 프레임 당 이미지를 아래로 이동 시킨다.

    6. 각각의 속도를 지정해 준다.
*/

/*
목표 : 스크롤링


    1. 현재 메인 카메라 사이즈 5, 배경 높이 12

    2. 화면 아래로 내려간 가장 밑의 배경 화면은 맨 위로 붙인다.

    3. 필요 속성 : 배경 스프라이트의 위치 배열, 시작인덱스, 끝 인덱스

    4. 시작 인덱스는 가장 위에 있는 배경, 끝 인덱스는 가장 아래 있는 배경

    5. 가장 아래 있는 배경의 y축 위치를 체크한다.
        위에 있는 배경의 localPosition과 아래 있는 배경의 localPosition을 미리 저장한다.
        가장 아래 있는 배경을 가장 위에 있는 배경의 위에 붙인다.(localPosition + Vector3.up * 10)

    6. 가장 아래 있는 배경의 y축 위치에서 옮길 기준이 될 값을 변수로 만든다.
        카메라의 size를 받아온다. Camera.main.orthographicSize * 2

    7. 위치를 바꾸었다면 시작 인덱스에 담을 값과 끝 인덱스에 담을 값의 교체가 이루어져야 한다.
        이 때 끝 인덱스가 0보다 작아지면 않되지 제어문을 만들어 0보다 작을 경우 2를 담도록 한다.
*/